From aa3e97971dadf222a93d89fce4af4dd583bb3457 Mon Sep 17 00:00:00 2001
From: shadow_walker <shadowwalkersb@gmail.com>
Date: Sun, 18 Dec 2016 22:56:49 -0600
Subject: [PATCH] Update GSL to version 2.2.1

---
 CMakeLists.txt                 |  695 ++++++++++++++++++++++++
 appveyor.yml                   |    8 +
 cmake/c_flag_overrides.cmake   |    6 +
 cmake/cxx_flag_overrides.cmake |    6 +
 cmake/init.cmake               |   92 ++++
 doc/examples/expfit.c          |   56 ++
 doc/multifit.texi              | 1170 ++++++++++++++++++++++++++++++++++++++++
 gsl.pc.cmake                   |   11 +
 ieee-utils/fp-win.c            |   70 +++
 9 files changed, 2114 insertions(+)
 create mode 100644 CMakeLists.txt
 create mode 100644 appveyor.yml
 create mode 100644 cmake/c_flag_overrides.cmake
 create mode 100644 cmake/cxx_flag_overrides.cmake
 create mode 100644 cmake/init.cmake
 create mode 100644 doc/examples/expfit.c
 create mode 100644 doc/multifit.texi
 create mode 100644 gsl.pc.cmake
 create mode 100644 ieee-utils/fp-win.c

diff --git a/CMakeLists.txt b/CMakeLists.txt
new file mode 100644
index 0000000..8882549
--- /dev/null
+++ b/CMakeLists.txt
@@ -0,0 +1,695 @@
+# CMake build script for the GNU Scientific Library.
+
+# Use CMake 2.8.3 for CMakeParseArguments.
+cmake_minimum_required(VERSION 2.8.3)
+
+set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${CMAKE_CURRENT_SOURCE_DIR}/cmake)
+include(init)
+
+project(GSL)
+
+if (POLICY CMP0054)
+  # Only interpret `if` arguments as variables or keywords when unquoted.
+  cmake_policy(SET CMP0054 NEW)
+endif ()
+
+set(PACKAGE "gsl")
+set(PACKAGE_NAME ${PACKAGE})
+set(PACKAGE_TARNAME ${PACKAGE})
+set(PACKAGE_BUGREPORT "")
+set(PACKAGE_URL "")
+set(LT_OBJDIR ".libs/")
+
+set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/bin)
+
+# The following part of config.h is hard to derive from configure.ac.
+string(REGEX MATCHALL "[^\n]*\n" CONFIG
+"/* Define if you have inline with C99 behavior */
+#undef HAVE_C99_INLINE
+
+/* Define to 1 if you have the declaration of `acosh', and to 0 if you don't.
+   */
+#undef HAVE_DECL_ACOSH
+
+/* Define to 1 if you have the declaration of `asinh', and to 0 if you don't.
+   */
+#undef HAVE_DECL_ASINH
+
+/* Define to 1 if you have the declaration of `atanh', and to 0 if you don't.
+   */
+#undef HAVE_DECL_ATANH
+
+/* Define to 1 if you have the declaration of `expm1', and to 0 if you don't.
+   */
+#undef HAVE_DECL_EXPM1
+
+/* Define to 1 if you have the declaration of `feenableexcept', and to 0 if
+   you don't. */
+#undef HAVE_DECL_FEENABLEEXCEPT
+
+/* Define to 1 if you have the declaration of `fesettrapenable', and to 0 if
+   you don't. */
+#undef HAVE_DECL_FESETTRAPENABLE
+
+/* Define to 1 if you have the declaration of `finite', and to 0 if you don't.
+   */
+#undef HAVE_DECL_FINITE
+
+/* Define to 1 if you have the declaration of `fprnd_t', and to 0 if you
+   don't. */
+#undef HAVE_DECL_FPRND_T
+
+/* Define to 1 if you have the declaration of `frexp', and to 0 if you don't.
+   */
+#undef HAVE_DECL_FREXP
+
+/* Define to 1 if you have the declaration of `hypot', and to 0 if you don't.
+   */
+#undef HAVE_DECL_HYPOT
+
+/* Define to 1 if you have the declaration of `isfinite', and to 0 if you
+   don't. */
+#undef HAVE_DECL_ISFINITE
+
+/* Define to 1 if you have the declaration of `isinf', and to 0 if you don't.
+   */
+#undef HAVE_DECL_ISINF
+
+/* Define to 1 if you have the declaration of `isnan', and to 0 if you don't.
+   */
+#undef HAVE_DECL_ISNAN
+
+/* Define to 1 if you have the declaration of `ldexp', and to 0 if you don't.
+   */
+#undef HAVE_DECL_LDEXP
+
+/* Define to 1 if you have the declaration of `log1p', and to 0 if you don't.
+   */
+#undef HAVE_DECL_LOG1P
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#undef HAVE_DLFCN_H
+
+/* Define to 1 if you don't have `vprintf' but do have `_doprnt.' */
+#undef HAVE_DOPRNT
+
+/* Defined if you have ansi EXIT_SUCCESS and EXIT_FAILURE in stdlib.h */
+#undef HAVE_EXIT_SUCCESS_AND_FAILURE
+
+/* Defined on architectures with excess floating-point precision */
+#undef HAVE_EXTENDED_PRECISION_REGISTERS
+
+/* Define if x86 processor has sse extensions. */
+#undef HAVE_FPU_X86_SSE
+
+/* Define to 1 if you have the <ieeefp.h> header file. */
+#undef HAVE_IEEEFP_H
+
+/* Define this if IEEE comparisons work correctly (e.g. NaN != NaN) */
+#undef HAVE_IEEE_COMPARISONS
+
+/* Define this if IEEE denormalized numbers are available */
+#undef HAVE_IEEE_DENORMALS
+
+/* Define if you have inline */
+#undef HAVE_INLINE
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#undef HAVE_INTTYPES_H
+
+/* Define to 1 if you have the `m' library (-lm). */
+#undef HAVE_LIBM
+
+/* Define to 1 if you have the `memcpy' function. */
+#undef HAVE_MEMCPY
+
+/* Define to 1 if you have the `memmove' function. */
+#undef HAVE_MEMMOVE
+
+/* Define to 1 if you have the <memory.h> header file. */
+#undef HAVE_MEMORY_H
+
+/* Define this if printf can handle %Lf for long double */
+#undef HAVE_PRINTF_LONGDOUBLE
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#undef HAVE_STDINT_H
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#undef HAVE_STDLIB_H
+
+/* Define to 1 if you have the `strdup' function. */
+#undef HAVE_STRDUP
+
+/* Define to 1 if you have the <strings.h> header file. */
+#undef HAVE_STRINGS_H
+
+/* Define to 1 if you have the <string.h> header file. */
+#undef HAVE_STRING_H
+
+/* Define to 1 if you have the `strtol' function. */
+#undef HAVE_STRTOL
+
+/* Define to 1 if you have the `strtoul' function. */
+#undef HAVE_STRTOUL
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#undef HAVE_SYS_STAT_H
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#undef HAVE_SYS_TYPES_H
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#undef HAVE_UNISTD_H
+
+/* Define to 1 if you have the `vprintf' function. */
+#undef HAVE_VPRINTF
+
+/* Define if you need to hide the static definitions of inline functions */
+#undef HIDE_INLINE_STATIC
+
+/* Define to the sub-directory in which libtool stores uninstalled libraries.
+   */
+#undef LT_OBJDIR
+
+/* Name of package */
+#undef PACKAGE
+
+/* Define to the address where bug reports for this package should be sent. */
+#undef PACKAGE_BUGREPORT
+
+/* Define to the full name of this package. */
+#undef PACKAGE_NAME
+
+/* Define to the full name and version of this package. */
+#undef PACKAGE_STRING
+
+/* Define to the one symbol short name of this package. */
+#undef PACKAGE_TARNAME
+
+/* Define to the home page for this package. */
+#undef PACKAGE_URL
+
+/* Define to the version of this package. */
+#undef PACKAGE_VERSION
+
+/* Defined if this is an official release */
+#undef RELEASED
+
+/* Define to 1 if you have the ANSI C header files. */
+#undef STDC_HEADERS
+
+/* Version number of package */
+#undef VERSION
+
+/* Define to 1 if type `char' is unsigned and you are not using gcc.  */
+#ifndef __CHAR_UNSIGNED__
+# undef __CHAR_UNSIGNED__
+#endif
+
+/* Define to `__inline__' or `__inline' if that's what the C compiler
+   calls it, or to nothing if 'inline' is not supported under any name.  */
+#ifndef __cplusplus
+#undef inline
+#endif
+
+/* Define to `unsigned int' if <sys/types.h> does not define. */
+#undef size_t
+
+/* Define to empty if the keyword `volatile' does not work. Warning: valid
+   code using `volatile' can become incorrect without. Disable with care. */
+#undef volatile
+")
+
+# Get version numbers and parts of config.h from configure.ac.
+file(READ configure.ac LINES)
+# Replace semicolons with "<semi>" to avoid CMake messing with them.
+string(REPLACE ";" "<semi>" LINES "${LINES}")
+# Split into lines keeping newlines to avoid foreach skipping empty ones.
+string(REGEX MATCHALL "[^\n]*\n" LINES "${LINES}")
+set(ah_command FALSE)
+foreach (line "${EXTRA_CONFIG}" ${LINES})
+  string(REPLACE ";" "" line "${line}")
+  if (ah_command)
+    # Do nothing.
+  elseif (line MATCHES "AC_INIT[^,]*,\\[(.*)\\].*")
+    set(VERSION ${CMAKE_MATCH_1})
+    message(STATUS "Got VERSION=${VERSION} from configure.ac")
+  elseif (line MATCHES "((GSL|CBLAS)_(CURRENT|REVISION|AGE))=(.*)\n")
+    set(${CMAKE_MATCH_1} ${CMAKE_MATCH_4})
+    message(STATUS "Got ${CMAKE_MATCH_1}=${CMAKE_MATCH_4} from configure.ac")
+  elseif (line MATCHES "AH_BOTTOM\\(\\[(.*)")
+    set(ah_command bottom)
+    set(line "${CMAKE_MATCH_1}")
+  elseif (line MATCHES "AH_VERBATIM[^,]+,(.*)")
+    set(ah_command verbatim)
+    set(line "${CMAKE_MATCH_1}")
+  endif ()
+  if (ah_command)
+    set(saved_ah_command ${ah_command})
+    if (line MATCHES "^\\[(.*)")
+      set(line "${CMAKE_MATCH_1}")
+    endif ()
+    if (line MATCHES "\\]\\)")
+      set(ah_command FALSE)
+      string(REPLACE "])" "" line "${line}")
+    endif ()
+    # For some reason CMake may bundle several lines together. Split them too.
+    string(REGEX MATCHALL "[^\n]*\n" sublines "${line}")
+    set(config_add "")
+    foreach (subline ${sublines})
+      set(config_add ${config_add} "${subline}")
+    endforeach ()
+    if (saved_ah_command STREQUAL "verbatim")
+      set(CONFIG ${config_add} ${CONFIG})
+    else ()
+      set(CONFIG ${CONFIG} "\n" ${config_add})
+    endif ()
+  endif ()
+endforeach ()
+set(PACKAGE_VERSION ${VERSION})
+set(PACKAGE_STRING "${PACKAGE} ${VERSION}")
+
+if (NOT (VERSION MATCHES "\\+"))
+  # Defined if this is an official release.
+  set(RELEASED /**/)
+endif ()
+
+include(CheckLibraryExists)
+check_library_exists(m cos "" HAVE_LIBM)
+if (HAVE_LIBM)
+  set(CMAKE_REQUIRED_LIBRARIES m)
+endif ()
+
+include(CheckCSourceCompiles)
+
+# Check for inline.
+foreach (keyword inline __inline__ __inline)
+  check_c_source_compiles("
+    static ${keyword} void foo() { return 0; }
+    int main() {}" C_HAS_${keyword})
+  if (C_HAS_${keyword})
+    set(C_INLINE ${keyword})
+    break ()
+  endif ()
+endforeach ()
+if (C_INLINE)
+  # Check for GNU-style extern inline.
+  check_c_source_compiles("
+    extern ${C_INLINE} double foo(double x);
+    extern ${C_INLINE} double foo(double x) { return x + 1.0; }
+    double foo(double x) { return x + 1.0; }
+    int main() { foo(1.0); }" C_EXTERN_INLINE)
+  if (C_EXTERN_INLINE)
+    set(HAVE_INLINE 1)
+  else ()
+    # Check for C99-style inline.
+    check_c_source_compiles("
+      extern inline void* foo() { foo(); return &foo; }
+      int main() { return foo() != 0; }" C_C99INLINE)
+    if (C_C99INLINE)
+      set(HAVE_INLINE 1)
+      set(HAVE_C99_INLINE 1)
+    endif ()
+  endif ()
+endif ()
+if (C_INLINE AND NOT C_HAS_inline)
+  set(inline ${C_INLINE})
+endif ()
+
+# Checks for header files.
+include(CheckIncludeFiles)
+foreach (header ieeefp.h dlfcn.h inttypes.h memory.h stdint.h stdlib.h
+                strings.h string.h sys/stat.h sys/types.h unistd.h)
+  string(TOUPPER HAVE_${header} var)
+  string(REGEX REPLACE "\\.|/" "_" var ${var})
+  check_include_files(${header} ${var})
+endforeach ()
+check_include_files(stdio.h STDC_HEADERS)
+
+# Check for IEEE arithmetic interface type.
+if (CMAKE_SYSTEM_NAME MATCHES Linux)
+  if (CMAKE_SYSTEM_PROCESSOR MATCHES sparc)
+    set(HAVE_GNUSPARC_IEEE_INTERFACE 1)
+  elseif (CMAKE_SYSTEM_PROCESSOR MATCHES powerpc)
+    set(HAVE_GNUPPC_IEEE_INTERFACE 1)
+  elseif (CMAKE_SYSTEM_PROCESSOR MATCHES 86)
+    set(HAVE_GNUX86_IEEE_INTERFACE 1)
+  endif ()
+elseif (CMAKE_SYSTEM_NAME MATCHES SunOS)
+  set(HAVE_SUNOS4_IEEE_INTERFACE 1)
+elseif (CMAKE_SYSTEM_NAME MATCHES Solaris)
+  set(HAVE_SOLARIS_IEEE_INTERFACE 1)
+elseif (CMAKE_SYSTEM_NAME MATCHES hpux)
+  set(HAVE_HPUX_IEEE_INTERFACE 1)
+elseif (CMAKE_SYSTEM_NAME MATCHES Darwin)
+  if (CMAKE_SYSTEM_PROCESSOR MATCHES powerpc)
+    set(HAVE_DARWIN_IEEE_INTERFACE 1)
+  elseif (CMAKE_SYSTEM_PROCESSOR MATCHES 86)
+    set(HAVE_DARWIN86_IEEE_INTERFACE 1)
+  endif ()
+elseif (CMAKE_SYSTEM_NAME MATCHES NetBSD)
+  set(HAVE_NETBSD_IEEE_INTERFACE 1)
+elseif (CMAKE_SYSTEM_NAME MATCHES OpenBSD)
+  set(HAVE_OPENBSD_IEEE_INTERFACE 1)
+elseif (CMAKE_SYSTEM_NAME MATCHES FreeBSD)
+  set(HAVE_FREEBSD_IEEE_INTERFACE 1)
+endif ()
+
+# Check for FPU_SETCW.
+if (HAVE_GNUX86_IEEE_INTERFACE)
+  check_c_source_compiles("
+    #include <fpu_control.h>
+    #ifndef _FPU_SETCW
+    #include <i386/fpu_control.h>
+    #define _FPU_SETCW(cw) __setfpucw(cw)
+    #endif
+    int main() { unsigned short mode = 0 ; _FPU_SETCW(mode); }"
+    HAVE_FPU_SETCW)
+  if (NOT HAVE_FPU_SETCW)
+    set(HAVE_GNUX86_IEEE_INTERFACE 0)
+  endif ()
+endif ()
+
+# Check for SSE extensions.
+if (HAVE_GNUX86_IEEE_INTERFACE)
+  check_c_source_compiles("
+    #include <stdlib.h>
+    #define _FPU_SETMXCSR(cw) asm volatile (\"ldmxcsr %0\" : : \"m\" (*&cw))
+    int main() { unsigned int mode = 0x1f80 ; _FPU_SETMXCSR(mode); exit(0); }"
+    HAVE_FPU_X86_SSE)
+endif ()
+
+# Compiles the source code, runs the program and sets ${VAR} to 1 if the
+# return value is equal to ${RESULT}.
+macro(check_run_result SRC RESULT VAR)
+  set(SRC_FILE ${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/CMakeTmp/src.c)
+  file(WRITE ${SRC_FILE} "${SRC}")
+  try_run(RUN_RESULT COMPILE_RESULT ${CMAKE_BINARY_DIR} ${SRC_FILE}
+          CMAKE_FLAGS -DLINK_LIBRARIES:STRING=${CMAKE_REQUIRED_LIBRARIES})
+  if (RUN_RESULT EQUAL ${RESULT})
+    set(${VAR} 1)
+  endif ()
+endmacro()
+
+# Check IEEE comparisons, whether "x != x" is true for NaNs.
+check_run_result("
+  #include <math.h>
+  int main (void)
+  {
+     int status; double inf, nan;
+     inf = exp(1.0e10);
+     nan = inf / inf ;
+     status = (nan == nan);
+     exit (status);
+  }" 0 HAVE_IEEE_COMPARISONS)
+
+# Check for IEEE denormalized arithmetic.
+check_run_result("
+  #include <math.h>
+  int main (void)
+  {
+     int i, status;
+     volatile double z = 1e-308;
+     for (i = 0; i < 5; i++) { z = z / 10.0 ; };
+     for (i = 0; i < 5; i++) { z = z * 10.0 ; };
+     status = (z == 0.0);
+     exit (status);
+  }" 0 HAVE_IEEE_DENORMALS)
+
+# Check for long double stdio.
+check_run_result("
+  #include <stdlib.h>
+  #include <stdio.h>
+  int main (void)
+  {
+    const char * s = \"5678.25\"; long double x = 1.234 ;
+    fprintf(stderr,\"%Lg\n\",x) ;
+    sscanf(s, \"%Lg\", &x);
+    if (x == 5678.25) {exit (0);} else {exit(1); }
+  }" 0 HAVE_PRINTF_LONGDOUBLE)
+
+if (NOT CMAKE_COMPILER_IS_GNUCC)
+  check_run_result("
+    #include <limits.h>
+    int main (void) { return CHAR_MIN == 0; }" 1 __CHAR_UNSIGNED__)
+endif ()
+
+# Remember to put a definition in config.h.in for each of these.
+include(CheckSymbolExists)
+check_symbol_exists(EXIT_SUCCESS stdlib.h HAVE_EXIT_SUCCESS)
+check_symbol_exists(EXIT_FAILURE stdlib.h HAVE_EXIT_FAILURE)
+if (HAVE_EXIT_SUCCESS AND HAVE_EXIT_FAILURE)
+  set(HAVE_EXIT_SUCCESS_AND_FAILURE 1)
+endif ()
+set(CMAKE_REQUIRED_DEFINITIONS "-D_GNU_SOURCE=1")
+check_symbol_exists(feenableexcept fenv.h HAVE_DECL_FEENABLEEXCEPT)
+check_symbol_exists(fesettrapenable fenv.h HAVE_DECL_FESETTRAPENABLE)
+set(CMAKE_REQUIRED_DEFINITIONS "")
+check_symbol_exists(hypot math.h HAVE_DECL_HYPOT)
+check_symbol_exists(expm1 math.h HAVE_DECL_EXPM1)
+check_symbol_exists(acosh math.h HAVE_DECL_ACOSH)
+check_symbol_exists(asinh math.h HAVE_DECL_ASINH)
+check_symbol_exists(atanh math.h HAVE_DECL_ATANH)
+check_symbol_exists(ldexp math.h HAVE_DECL_LDEXP)
+check_symbol_exists(frexp math.h HAVE_DECL_FREXP)
+check_symbol_exists(fprnd_t float.h HAVE_DECL_FPRND_T)
+check_symbol_exists(isinf math.h HAVE_DECL_ISINF)
+check_symbol_exists(isfinite math.h HAVE_DECL_ISFINITE)
+if (HAVE_IEEEFP_H)
+  set(IEEEFP_H ieeefp.h)
+endif ()
+check_symbol_exists(finite math.h;${IEEEFP_H} HAVE_DECL_FINITE)
+check_symbol_exists(isnan math.h HAVE_DECL_ISNAN)
+
+# OpenBSD has a broken implementation of log1p.
+if (CMAKE_SYSTEM_NAME MATCHES OpenBSD)
+  message("avoiding OpenBSD system log1p - using gsl version")
+else ()
+  check_symbol_exists(log1p math.h HAVE_DECL_LOG1P)
+endif ()
+
+# Check for extended floating point registers.
+if (NOT (CMAKE_SYSTEM_PROCESSOR MATCHES "^(sparc|powerpc|hppa|alpha)"))
+  set(HAVE_EXTENDED_PRECISION_REGISTERS 1)
+endif ()
+
+check_symbol_exists(memcpy string.h HAVE_MEMCPY)
+check_symbol_exists(memmove string.h HAVE_MEMMOVE)
+check_symbol_exists(strdup string.h HAVE_STRDUP)
+check_symbol_exists(strtol stdlib.h HAVE_STRTOL)
+check_symbol_exists(strtoul stdlib.h HAVE_STRTOUL)
+check_symbol_exists(vprintf stdio.h HAVE_VPRINTF)
+
+# Process config.h using autoconf rules.
+#file(STRINGS ${GSL_SOURCE_DIR}/config.h.in CONFIG)
+list(LENGTH CONFIG length)
+math(EXPR length "${length} - 1")
+foreach (i RANGE ${length})
+  list(GET CONFIG ${i} line)
+  if (line MATCHES "^#( *)undef (.*)\n")
+    set(space "${CMAKE_MATCH_1}")
+    set(var ${CMAKE_MATCH_2})
+    if (NOT DEFINED ${var} OR (var MATCHES "HAVE_.*_H" AND NOT ${var}))
+      set(line "/* #${space}undef ${var} */\n")
+    else ()
+      if ("${${var}}" STREQUAL "/**/" OR "${var}" STREQUAL "inline")
+        set(value ${${var}})
+      elseif (NOT (var MATCHES ^HAVE OR ${var} EQUAL 0 OR ${var} EQUAL 1))
+        set(value \"${${var}}\")
+      elseif (${var})
+        set(value 1)
+      else ()
+        set(value 0)
+      endif ()
+      set(line "#${space}define ${var} ${value}\n")
+    endif ()
+  elseif (BUILD_SHARED_LIBS AND WIN32 AND line MATCHES "^#define GSL_DISABLE_DEPRECATED .*")
+    # Keep deprecated symbols when compiling a Windows DLL to prevent linkage errors.
+    set(line "/* #undef GSL_DISABLE_DEPRECATED */\n")
+  endif ()
+  string(REPLACE "<semi>" ";" line "${line}")
+  set(CONFIG_OUT "${CONFIG_OUT}${line}")
+endforeach ()
+file(WRITE ${GSL_BINARY_DIR}/config.h
+"/* config.h.  Generated from config.h.in by configure.  */
+/* config.h.in.  Generated from configure.ac by autoheader.  */
+
+${CONFIG_OUT}")
+
+include_directories(${GSL_BINARY_DIR} ${GSL_SOURCE_DIR})
+add_definitions(-DHAVE_CONFIG_H)
+
+if (GSL_DISABLE_WARNINGS)
+  # Disable additional warnings.
+  if (MSVC)
+    add_definitions(
+      -D_CRT_SECURE_NO_WARNINGS
+      /wd4018 /wd4028 /wd4056 /wd4244 /wd4267 /wd4334 /wd4700 /wd4723 /wd4756)
+  else ()
+    foreach (flag -Wall -Wextra -pedantic)
+      string(REPLACE ${flag} "" CMAKE_C_FLAGS "${CMAKE_C_FLAGS}")
+    endforeach ()
+  endif ()
+endif ()
+
+option(MSVC_RUNTIME_DYNAMIC "Use dynamically-linked runtime: /MD(d)" OFF)
+
+if (MSVC_RUNTIME_DYNAMIC)
+  set(CMAKE_COMPILER_FLAGS_VARIABLES
+    CMAKE_C_FLAGS_DEBUG
+    CMAKE_C_FLAGS_MINSIZEREL
+    CMAKE_C_FLAGS_RELEASE
+    CMAKE_C_FLAGS_RELWITHDEBINFO
+    CMAKE_CXX_FLAGS_DEBUG
+    CMAKE_CXX_FLAGS_MINSIZEREL
+    CMAKE_CXX_FLAGS_RELEASE
+    CMAKE_CXX_FLAGS_RELWITHDEBINFO
+  )
+  foreach(variable ${CMAKE_COMPILER_FLAGS_VARIABLES})
+    string(REGEX REPLACE "/MT" "/MD" ${variable} "${${variable}}")
+  endforeach()
+endif ()
+
+enable_testing()
+
+# Adds a GSL test. Usage:
+#   add_gsl_test(<exename> <source> ...)
+function(add_gsl_test exename)
+  if (GSL_DISABLE_TESTS)
+    return()
+  endif ()
+  add_executable(${exename} ${ARGN})
+  target_link_libraries(${exename} gsl)
+  add_test(${exename} ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/${exename})
+endfunction()
+
+file(GLOB GSL_HEADER_PATHS "${GSL_SOURCE_DIR}/gsl*.h")
+file(GLOB dirs "${GSL_SOURCE_DIR}/*")
+foreach (dir ${dirs})
+  if (NOT (dir MATCHES "gsl$"))
+    file(GLOB headers "${dir}/gsl*.h")
+    set(GSL_HEADER_PATHS ${GSL_HEADER_PATHS} ${headers})
+  endif ()
+endforeach()
+
+foreach (path ${GSL_HEADER_PATHS})
+  get_filename_component(name ${path} NAME)
+  set(GSL_HEADERS ${GSL_HEADERS} gsl/${name})
+endforeach ()
+
+file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/copy-headers.cmake "
+  file(MAKE_DIRECTORY gsl)
+  foreach (path ${GSL_HEADER_PATHS})
+    get_filename_component(filename \${path} NAME)
+    configure_file(\${path} ${GSL_BINARY_DIR}/gsl/\${filename} COPYONLY)
+  endforeach ()")
+
+add_custom_command(OUTPUT ${GSL_HEADERS}
+  COMMAND ${CMAKE_COMMAND} -P copy-headers.cmake)
+add_custom_target(copy-headers DEPENDS ${GSL_HEADERS})
+
+macro(get_sources dir line source_var)
+  set(${source_var})
+  string(REGEX REPLACE ".*_SOURCES[ \t]*=(.*)" "\\1" sources ${line})
+  string(REGEX MATCHALL "[^ \t]+" sources ${sources})
+  foreach (src ${sources})
+    set(${source_var} ${${source_var}} ${dir}/${src})
+  endforeach ()
+endmacro()
+
+# Get subdirectories from Makefile.am.
+file(STRINGS Makefile.am lines REGEX "^SUBDIRS[ \t]*=")
+foreach (line ${lines})
+  string(REGEX REPLACE "SUBDIRS[ \t]*=(.*)" "\\1" dirs ${line})
+  string(REGEX MATCHALL "[^ ]+" dirs ${dirs})
+endforeach ()
+
+# Extract sources from automake files and add tests.
+foreach (dir "." ${dirs})
+  file(STRINGS ${dir}/Makefile.am lines)
+  foreach (line ${lines})
+    if (line MATCHES "_la_SOURCES[ \t]*=")
+      get_sources(${dir} "${line}" SOURCES)
+      if (dir STREQUAL cblas)
+        # Build gslcblas as a static library on MSVC because it doesn't have a .def file.
+        if (MSVC)
+          set(GSLCBLAS_TYPE STATIC)
+        endif ()
+        add_library(gslcblas ${GSLCBLAS_TYPE} ${SOURCES})
+        target_link_libraries(gslcblas ${CMAKE_REQUIRED_LIBRARIES})
+        add_dependencies(gslcblas copy-headers)
+      else ()
+        set(GSL_SOURCES ${GSL_SOURCES} ${SOURCES})
+      endif ()
+    elseif (line MATCHES "^test.*_SOURCES[ \t]*=")
+      get_sources(${dir} "${line}" SOURCES)
+      string(REGEX REPLACE "(.*)_SOURCES.*" "\\1" suffix ${line})
+      add_gsl_test("${dir}_${suffix}" ${SOURCES})
+    endif ()
+  endforeach ()
+endforeach ()
+
+if (BUILD_SHARED_LIBS)
+  include(CheckCCompilerFlag)
+  check_c_compiler_flag(-fPIC HAVE_FPIC)
+  if (HAVE_FPIC)
+    add_definitions(-fPIC)
+  endif ()
+  if (WIN32)
+    add_definitions(-DGSL_DLL)
+    # Extract function names from header and generate a .def file.
+    file(WRITE gsl.def "LIBRARY GSL\nEXPORTS\n")
+    foreach (header ${GSL_HEADER_PATHS})
+      file(READ ${header} content)
+      string(REGEX REPLACE
+        "/\\*([^*]|[\r\n]|(\\*+([^*/]|[\r\n])))*\\*+/" " " content "${content}")
+      set(RE "\n([^\n]*[ *])?(gsl_[A-Za-z0-9_]+)[ ]*\\(")
+      string(REGEX MATCHALL "${RE}" candidates "${content}")
+      foreach (line ${candidates})
+        if (NOT line MATCHES typedef AND line MATCHES "${RE}")
+          file(APPEND gsl.def "   ${CMAKE_MATCH_2}\n")
+        endif ()
+      endforeach ()
+    endforeach ()
+    set(GSL_SOURCES ${GSL_SOURCES} gsl.def)
+  endif ()
+endif ()
+
+add_library(gsl ${shared} ${GSL_SOURCES})
+set_target_properties(gsl PROPERTIES COMPILE_DEFINITIONS DLL_EXPORT)
+target_link_libraries(gsl gslcblas)
+add_dependencies(gsl copy-headers)
+
+option(GSL_INSTALL_MULTI_CONFIG "Install libraries in lib/<config> directory" OFF)
+
+if (GSL_INSTALL OR NOT DEFINED GSL_INSTALL)
+  if (MSVC AND GSL_INSTALL_MULTI_CONFIG)
+    foreach(config ${CMAKE_CONFIGURATION_TYPES})
+      install(TARGETS gsl gslcblas
+        CONFIGURATIONS ${config}
+        LIBRARY DESTINATION lib/${config}
+        RUNTIME DESTINATION bin/${config}
+        ARCHIVE DESTINATION lib/${config})
+    endforeach ()
+    install(FILES ${PROJECT_BINARY_DIR}/Debug/gsl.pdb
+                  ${PROJECT_BINARY_DIR}/Debug/gslcblas.pdb
+          DESTINATION lib/Debug
+          CONFIGURATIONS Debug)
+  else ()
+    install(TARGETS gsl gslcblas
+      LIBRARY DESTINATION lib
+      RUNTIME DESTINATION bin
+      ARCHIVE DESTINATION lib)
+    if (MSVC)
+      install(FILES ${PROJECT_BINARY_DIR}/Debug/gsl.pdb
+                    ${PROJECT_BINARY_DIR}/Debug/gslcblas.pdb
+            DESTINATION lib
+            CONFIGURATIONS Debug)
+    endif ()
+  endif ()
+  install(FILES ${GSL_HEADER_PATHS} DESTINATION include/gsl)
+  set(PC_FILE ${CMAKE_BINARY_DIR}/gsl.pc)
+  configure_file("gsl.pc.cmake" ${PC_FILE} @ONLY)
+  install(FILES ${PC_FILE} DESTINATION lib/pkgconfig)
+endif ()
diff --git a/appveyor.yml b/appveyor.yml
new file mode 100644
index 0000000..979ab56
--- /dev/null
+++ b/appveyor.yml
@@ -0,0 +1,8 @@
+install: set PATH=C:\Program Files (x86)\MSBuild\14.0\Bin;%PATH%
+
+before_build:
+  - cmake .
+
+build_script:
+  - msbuild /m GSL.sln
+  - msbuild RUN_TESTS.vcxproj
diff --git a/cmake/c_flag_overrides.cmake b/cmake/c_flag_overrides.cmake
new file mode 100644
index 0000000..e72f341
--- /dev/null
+++ b/cmake/c_flag_overrides.cmake
@@ -0,0 +1,6 @@
+if (MSVC)
+  set(CMAKE_C_FLAGS_DEBUG_INIT          "/MP /D_DEBUG /MTd /Zi /Ob0 /Od /RTC1")
+  set(CMAKE_C_FLAGS_MINSIZEREL_INIT     "/MP /MT /O1 /Ob1 /D NDEBUG")
+  set(CMAKE_C_FLAGS_RELEASE_INIT        "/MP /MT /O2 /Ob2 /D NDEBUG")
+  set(CMAKE_C_FLAGS_RELWITHDEBINFO_INIT "/MP /MT /Zi /O2 /Ob1 /D NDEBUG")
+endif ()
diff --git a/cmake/cxx_flag_overrides.cmake b/cmake/cxx_flag_overrides.cmake
new file mode 100644
index 0000000..9d83af5
--- /dev/null
+++ b/cmake/cxx_flag_overrides.cmake
@@ -0,0 +1,6 @@
+if (MSVC)
+  set(CMAKE_CXX_FLAGS_DEBUG_INIT          "/MP /D_DEBUG /MTd /Zi /Ob0 /Od /RTC1")
+  set(CMAKE_CXX_FLAGS_MINSIZEREL_INIT     "/MP /MT /O1 /Ob1 /D NDEBUG")
+  set(CMAKE_CXX_FLAGS_RELEASE_INIT        "/MP /MT /O2 /Ob2 /D NDEBUG")
+  set(CMAKE_CXX_FLAGS_RELWITHDEBINFO_INIT "/MP /MT /Zi /O2 /Ob1 /D NDEBUG")
+endif ()
diff --git a/cmake/init.cmake b/cmake/init.cmake
new file mode 100644
index 0000000..df402ae
--- /dev/null
+++ b/cmake/init.cmake
@@ -0,0 +1,92 @@
+# CMake initialization code that should be run before the project command.
+
+include(CMakeParseArguments)
+
+# Joins arguments and sets the result to <var>.
+# Usage:
+#   join(<var> [<arg>...])
+function (join var)
+  unset(result)
+  foreach (arg ${ARGN})
+    if (DEFINED result)
+      set(result "${result} ${arg}")
+    else ()
+      set(result "${arg}")
+    endif ()
+  endforeach ()
+  set(${var} "${result}" PARENT_SCOPE)
+endfunction ()
+
+# Sets cache variable <var> to the value <value>. The arguments
+# following <type> are joined into a single docstring which allows
+# breaking long documentation into smaller strings.
+# Usage:
+#   set_cache(<var> <value> <type> docstring... [FORCE])
+function (set_cache var value type)
+  cmake_parse_arguments(set_cache FORCE "" "" ${ARGN})
+  unset(force)
+  if (set_cache_FORCE)
+    set(force FORCE)
+  endif ()
+  join(docstring ${set_cache_UNPARSED_ARGUMENTS})
+  set(${var} ${value} CACHE ${type} "${docstring}" ${force})
+endfunction ()
+
+if (NOT CMAKE_BUILD_TYPE)
+  # Set the default CMAKE_BUILD_TYPE to Release.
+  # This should be done before the project command since the latter sets
+  # CMAKE_BUILD_TYPE itself.
+  set_cache(CMAKE_BUILD_TYPE Release STRING
+    "Choose the type of build, options are: None(CMAKE_CXX_FLAGS or"
+    "CMAKE_C_FLAGS used) Debug Release RelWithDebInfo MinSizeRel.")
+endif ()
+
+function (override var file)
+  if (EXISTS "${file}")
+    set(${var} ${file} PARENT_SCOPE)
+  endif ()
+endfunction ()
+
+# Set compiler options (MSVC)
+# This should be done before the project command.
+override(CMAKE_USER_MAKE_RULES_OVERRIDE
+  ${CMAKE_CURRENT_LIST_DIR}/c_flag_overrides.cmake)
+override(CMAKE_USER_MAKE_RULES_OVERRIDE_CXX
+  ${CMAKE_CURRENT_LIST_DIR}/cxx_flag_overrides.cmake)
+
+if (MP_WINSDK)
+  # Find Windows SDK.
+  set(winsdk_key
+    "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Microsoft SDKs\\Windows")
+  find_program(MP_SETENV NAMES SetEnv.cmd
+    PATHS "[${winsdk_key};CurrentInstallFolder]/bin")
+  if (MP_SETENV)
+    if (NOT CMAKE_GENERATOR MATCHES Win64)
+      set(setenv_arg "/x86")
+    endif ()
+
+    # Call SetEnv.cmd and set environment variables accordingly.
+    message(STATUS "Found SetEnv: ${MP_SETENV}")
+    set(run_setenv "CMakeFiles\\run-setenv.bat")
+    file(WRITE ${run_setenv} "call %*\nset\n")
+    execute_process(COMMAND ${run_setenv} "${MP_SETENV}" "${setenv_arg}"
+      OUTPUT_VARIABLE out ERROR_VARIABLE err)
+    string(REPLACE ";" "\;" out "${out}")
+    string(REGEX MATCHALL "[^\n]+\n" out "${out}")
+    foreach (env ${out})
+      if (env MATCHES "([^=]+)=(.*)\n")
+        set(ENV{${CMAKE_MATCH_1}} "${CMAKE_MATCH_2}")
+      endif ()
+    endforeach ()
+
+    # If Microsoft SDK is installed create script run-msbuild.bat that
+    # calls SetEnv.cmd to set up build environment and runs msbuild.
+    # It is useful when building Visual Studio projects with the SDK
+    # toolchain rather than Visual Studio.
+    # Set FrameworkPathOverride to get rid of MSB3644 warnings.
+    file(WRITE "${CMAKE_BINARY_DIR}/run-msbuild.bat" "
+      call \"${MP_SETENV}\" ${setenv_arg}
+      msbuild -p:FrameworkPathOverride=^\"C:\\Program Files^
+\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.0^\" %*")
+  endif ()
+endif ()
diff --git a/doc/examples/expfit.c b/doc/examples/expfit.c
new file mode 100644
index 0000000..328177a
--- /dev/null
+++ b/doc/examples/expfit.c
@@ -0,0 +1,56 @@
+/* expfit.c -- model functions for exponential + background */
+
+struct data {
+  size_t n;
+  double * y;
+};
+
+int
+expb_f (const gsl_vector * x, void *data, 
+        gsl_vector * f)
+{
+  size_t n = ((struct data *)data)->n;
+  double *y = ((struct data *)data)->y;
+
+  double A = gsl_vector_get (x, 0);
+  double lambda = gsl_vector_get (x, 1);
+  double b = gsl_vector_get (x, 2);
+
+  size_t i;
+
+  for (i = 0; i < n; i++)
+    {
+      /* Model Yi = A * exp(-lambda * i) + b */
+      double t = i;
+      double Yi = A * exp (-lambda * t) + b;
+      gsl_vector_set (f, i, Yi - y[i]);
+    }
+
+  return GSL_SUCCESS;
+}
+
+int
+expb_df (const gsl_vector * x, void *data, 
+         gsl_matrix * J)
+{
+  size_t n = ((struct data *)data)->n;
+
+  double A = gsl_vector_get (x, 0);
+  double lambda = gsl_vector_get (x, 1);
+
+  size_t i;
+
+  for (i = 0; i < n; i++)
+    {
+      /* Jacobian matrix J(i,j) = dfi / dxj, */
+      /* where fi = (Yi - yi)/sigma[i],      */
+      /*       Yi = A * exp(-lambda * i) + b  */
+      /* and the xj are the parameters (A,lambda,b) */
+      double t = i;
+      double e = exp(-lambda * t);
+      gsl_matrix_set (J, i, 0, e); 
+      gsl_matrix_set (J, i, 1, -t * A * e);
+      gsl_matrix_set (J, i, 2, 1.0);
+    }
+  return GSL_SUCCESS;
+}
diff --git a/doc/multifit.texi b/doc/multifit.texi
new file mode 100644
index 0000000..318eddc
--- /dev/null
+++ b/doc/multifit.texi
@@ -0,0 +1,1170 @@
+@cindex nonlinear least squares fitting
+@cindex least squares fitting, nonlinear
+
+This chapter describes functions for multidimensional nonlinear
+least-squares fitting.  The library provides low level components for a
+variety of iterative solvers and convergence tests.  These can be
+combined by the user to achieve the desired solution, with full access
+to the intermediate steps of the iteration.  Each class of methods uses
+the same framework, so that you can switch between solvers at runtime
+without needing to recompile your program.  Each instance of a solver
+keeps track of its own state, allowing the solvers to be used in
+multi-threaded programs.
+
+The header file @file{gsl_multifit_nlin.h} contains prototypes for the
+multidimensional nonlinear fitting functions and related declarations.
+
+@menu
+* Overview of Nonlinear Least-Squares Fitting::  
+* Overview of Weighted Nonlinear Least-Squares Fitting::  
+* Overview of Regularized Nonlinear Least-Squares Fitting::  
+* Initializing the Nonlinear Least-Squares Solver::  
+* Providing the Function to be Minimized::  
+* Finite Difference Jacobian::  
+* Iteration of the Minimization Algorithm::  
+* Search Stopping Parameters for Minimization Algorithms::  
+* High Level Driver::
+* Minimization Algorithms using Derivatives::  
+* Minimization Algorithms without Derivatives::  
+* Computing the covariance matrix of best fit parameters::  
+* Troubleshooting Nonlinear Least Squares::
+* Example programs for Nonlinear Least-Squares Fitting::  
+* References and Further Reading for Nonlinear Least-Squares Fitting::  
+@end menu
+
+@node Overview of Nonlinear Least-Squares Fitting
+@section Overview
+@cindex nonlinear least squares fitting, overview
+
+The problem of multidimensional nonlinear least-squares fitting requires
+the minimization of the squared residuals of @math{n} functions,
+@math{f_i}, in @math{p} parameters, @math{x_i},
+@tex
+\beforedisplay
+$$
+\Phi(x)  = {1 \over 2} || f(x) ||^2
+         = {1 \over 2} \sum_{i=1}^{n} f_i (x_1, \dots, x_p)^2
+$$
+\afterdisplay
+@end tex
+@ifinfo
+
+@example
+\Phi(x) = (1/2) || f(x) ||^2
+        = (1/2) \sum_@{i=1@}^@{n@} f_i(x_1, ..., x_p)^2 
+@end example
+
+@end ifinfo
+@noindent
+All algorithms proceed from an initial guess using the linearization,
+@tex
+\beforedisplay
+$$
+\psi(\delta) = || f(x+\delta) || \approx || f(x) + J \delta\, ||
+$$
+\afterdisplay
+@end tex
+@ifinfo
+
+@example
+\psi(\delta) = || f(x+\delta) || ~=~ || f(x) + J \delta ||
+@end example
+
+@end ifinfo
+@noindent
+where @math{x} is the initial point, @math{\delta} is the proposed step
+and @math{J} is the
+Jacobian matrix @c{$J_{ij} = \partial f_i / \partial x_j$}
+@math{J_@{ij@} = d f_i / d x_j}.  
+Additional strategies are used to enlarge the region of convergence.
+These include requiring a decrease in the norm @math{||f||} on each
+step or using a trust region to avoid steps which fall outside the linear 
+regime.
+
+@noindent
+Note that the model parameters are denoted by @math{x} in this chapter
+since the non-linear least-squares algorithms are described
+geometrically (i.e. finding the minimum of a surface).  The
+independent variable of any data to be fitted is denoted by @math{t}.
+
+@node Overview of Weighted Nonlinear Least-Squares Fitting
+@section Weighted Nonlinear Least-Squares
+
+Weighted nonlinear least-squares fitting minimizes the function
+@tex
+\beforedisplay
+$$
+\Phi(x)  = {1 \over 2} f^T W f
+         = {1 \over 2} \sum_{i=1}^{n} w_i f_i (x_1, \dots, x_p)^2
+$$
+\afterdisplay
+@end tex
+@ifinfo
+
+@example
+\Phi(x) = (1/2) || f(x) ||^2
+        = (1/2) \sum_@{i=1@}^@{n@} f_i(x_1, ..., x_p)^2 
+@end example
+
+@end ifinfo
+where @math{W = diag(w_1,w_2,...,w_n)} is the weighting matrix,
+and the weights @math{w_i} are commonly defined as @math{w_i = 1/\sigma_i^2},
+where @math{\sigma_i} is the error in the @math{i}th measurement.
+A simple change of variables @math{\tilde{f} = \sqrt{W} f} yields
+@math{\Phi(x) = {1 \over 2} ||\tilde{f}||^2}, which is in the
+same form as the unweighted case. The user can either perform this
+transform directly on their function residuals and Jacobian, or use
+the @code{gsl_multifit_fdfsolver_wset} interface which automatically
+performs the correct scaling. To manually perform this transformation,
+the residuals and Jacobian should be modified according to
+@tex
+\beforedisplay
+$$
+\eqalign{
+f_i & = \sqrt{w_i} (Y_i - y_i) = {(Y_i - y_i) \over \sigma_i} \cr
+J_{ij} & = \sqrt{w_i} { \partial Y_i \over \partial x_j } = { 1 \over \sigma_i} { \partial Y_i \over \partial x_j }
+}
+$$
+\afterdisplay
+@end tex
+@ifinfo
+
+@example
+f_i = (Y(x, t_i) - y_i) / \sigma_i
+@end example
+
+@end ifinfo
+where @math{Y_i = Y(x,t_i)}.
+
+@node Overview of Regularized Nonlinear Least-Squares Fitting
+@section Regularized Nonlinear Least-Squares
+In cases where the Jacobian @math{J} is rank-deficient or singular,
+standard nonlinear least squares can sometimes produce
+undesirable and unstable solutions. In these cases, it can
+help to regularize the problem using ridge or Tikhonov regularization.
+In this method, we introduce a term in our minimization function
+which is designed to damp the solution vector @math{x}, or give preference
+to solutions with smaller norms.
+@tex
+\beforedisplay
+$$
+\Phi(x)  = {1 \over 2} || f(x) ||^2 + {1 \over 2} || L x ||^2
+$$
+\afterdisplay
+@end tex
+@ifinfo
+
+@example
+\Phi(x) = (1/2) || f(x) ||^2 + (1/2) ||Lx||^2
+@end example
+
+@end ifinfo
+Here, the regularization matrix @math{L} is often set
+as @math{L = \lambda I}, for a positive scalar @math{\lambda}, but can
+also be a general @math{m}-by-@math{p} (where @math{m} is any number
+of rows) matrix depending on the
+structure of the problem to be solved. If we define a new
+@math{(n+m)}-by-1 vector
+@tex
+\beforedisplay
+$$
+\tilde{f}(x) =
+\left[
+\matrix{
+f(x) \cr
+L x
+}
+\right]
+$$
+\afterdisplay
+@end tex
+@ifinfo
+
+@example
+f~(x) = [ f(x); Lx ]
+@end example
+
+@end ifinfo
+or, in the weighted case,
+@tex
+\beforedisplay
+$$
+\tilde{f}(x) =
+\left[
+\matrix{
+\sqrt{W} f(x) \cr
+L x
+}
+\right]
+$$
+\afterdisplay
+@end tex
+@ifinfo
+
+@example
+f~(x) = [ sqrt(W) f(x); Lx ]
+@end example
+
+@end ifinfo
+then
+@tex
+\beforedisplay
+$$
+\Phi(x)  = {1 \over 2} || \tilde{f}(x) ||^2
+$$
+\afterdisplay
+@end tex
+@ifinfo
+
+@example
+\Phi(x) = (1/2) || f~(x) ||^2
+@end example
+
+@end ifinfo
+which is in the same form as the standard nonlinear least squares
+problem. The corresponding @math{(n+m)}-by-@math{p} Jacobian matrix is
+@tex
+\beforedisplay
+$$
+\tilde{J} =
+\left[
+\matrix{
+J \cr
+L
+}
+\right]
+$$
+\afterdisplay
+@end tex
+@ifinfo
+
+@example
+F~(x) = [ J; L ]
+@end example
+
+@end ifinfo
+or for weighted systems
+@tex
+\beforedisplay
+$$
+\tilde{J} =
+\left[
+\matrix{
+\sqrt{W} J \cr
+L
+}
+\right]
+$$
+\afterdisplay
+@end tex
+@ifinfo
+
+@example
+F~(x) = [ sqrt(W) J; L ]
+@end example
+
+@end ifinfo
+While the user could explicitly form the @math{\tilde{f}(x)} vector
+and @math{\tilde{J}} matrix, the @code{fdfridge} interface
+described below allows the user to specify the original data vector
+@math{f(x)}, Jacobian @math{J}, regularization matrix
+@math{L}, and optional weighting matrix @math{W}, and automatically
+forms @math{\tilde{f}(x)} and
+@math{\tilde{J}} to solve the system. This allows switching
+between regularized and non-regularized solutions with minimal
+code changes.
+
+@node Initializing the Nonlinear Least-Squares Solver
+@section Initializing the Solver
+
+@deftypefun {gsl_multifit_fsolver *} gsl_multifit_fsolver_alloc (const gsl_multifit_fsolver_type * @var{T}, size_t @var{n}, size_t @var{p})
+@tindex gsl_multifit_fsolver
+@tindex gsl_multifit_fsolver_type
+This function returns a pointer to a newly allocated instance of a
+solver of type @var{T} for @var{n} observations and @var{p} parameters.
+The number of observations @var{n} must be greater than or equal to
+parameters @var{p}. 
+
+If there is insufficient memory to create the solver then the function
+returns a null pointer and the error handler is invoked with an error
+code of @code{GSL_ENOMEM}.
+@end deftypefun
+
+@deftypefun {gsl_multifit_fdfsolver *} gsl_multifit_fdfsolver_alloc (const gsl_multifit_fdfsolver_type * @var{T}, size_t @var{n}, size_t @var{p})
+@tindex gsl_multifit_fdfsolver
+@tindex gsl_multifit_fdfsolver_type
+This function returns a pointer to a newly allocated instance of a
+derivative solver of type @var{T} for @var{n} observations and @var{p}
+parameters.  For example, the following code creates an instance of a
+Levenberg-Marquardt solver for 100 data points and 3 parameters,
+
+@example
+const gsl_multifit_fdfsolver_type * T 
+    = gsl_multifit_fdfsolver_lmder;
+gsl_multifit_fdfsolver * s 
+    = gsl_multifit_fdfsolver_alloc (T, 100, 3);
+@end example
+
+@noindent
+The number of observations @var{n} must be greater than or equal to
+parameters @var{p}.
+
+If there is insufficient memory to create the solver then the function
+returns a null pointer and the error handler is invoked with an error
+code of @code{GSL_ENOMEM}.
+@end deftypefun
+
+@deftypefun {gsl_multifit_fdfridge *} gsl_multifit_fdfridge_alloc (const gsl_multifit_fdfsolver_type * @var{T}, size_t @var{n}, size_t @var{p})
+@tindex gsl_multifit_fdfridge
+This function returns a pointer to a newly allocated instance of a
+derivative solver of type @var{T} for @var{n} observations and @var{p}
+parameters. The solver will automatically form the augmented
+system @math{\tilde{f}(x)} and @math{\tilde{J}} for ridge (Tikhonov)
+regression.
+If there is insufficient memory to create the solver then the function
+returns a null pointer and the error handler is invoked with an error
+code of @code{GSL_ENOMEM}.
+@end deftypefun
+
+@deftypefun int gsl_multifit_fsolver_set (gsl_multifit_fsolver * @var{s}, gsl_multifit_function * @var{f}, const gsl_vector * @var{x})
+This function initializes, or reinitializes, an existing solver @var{s}
+to use the function @var{f} and the initial guess @var{x}.
+@end deftypefun
+
+@deftypefun int gsl_multifit_fdfsolver_set (gsl_multifit_fdfsolver * @var{s}, gsl_multifit_function_fdf * @var{fdf}, const gsl_vector * @var{x})
+@deftypefunx int gsl_multifit_fdfsolver_wset (gsl_multifit_fdfsolver * @var{s}, gsl_multifit_function_fdf * @var{fdf}, const gsl_vector * @var{x}, const gsl_vector * @var{wts})
+These functions initialize, or reinitialize, an existing solver @var{s}
+to use the function and derivative @var{fdf} and the initial guess
+@var{x}.
+
+Optionally, a weight vector @var{wts} can be given to perform
+a weighted nonlinear regression. Here, the weighting matrix is
+@math{W = diag(w_1,w_2,...,w_n)}. The @var{wts} vector is referenced
+throughout the iteration so it should not be freed by the caller until
+the iteration terminates.
+@end deftypefun
+
+@deftypefun int gsl_multifit_fdfridge_set (gsl_multifit_fdfridge * @var{s}, gsl_multifit_function_fdf * @var{fdf}, const gsl_vector * @var{x}, const double @var{lambda})
+@deftypefunx int gsl_multifit_fdfridge_wset (gsl_multifit_fdfridge * @var{s}, gsl_multifit_function_fdf * @var{fdf}, const gsl_vector * @var{x}, const double @var{lambda}, const gsl_vector * @var{wts})
+This function initializes, or reinitializes, an existing ridge solver
+@var{s} to use the function and derivative @var{fdf} and the initial guess
+@var{x}. Here, the regularization matrix is set to @math{L = \lambda I},
+with @math{\lambda} specified in @var{lambda}.
+
+Optionally, a weight vector @var{wts} can be given to perform
+a weighted nonlinear regression. Here, the weighting matrix is
+@math{W = diag(w_1,w_2,...,w_n)}. The @var{wts} vector is referenced
+throughout the iteration so it should not be freed by the caller until
+the iteration terminates.
+@end deftypefun
+
+@deftypefun int gsl_multifit_fdfridge_set2 (gsl_multifit_fdfridge * @var{s}, gsl_multifit_function_fdf * @var{fdf}, const gsl_vector * @var{x}, const gsl_vector * @var{lambda})
+@deftypefunx int gsl_multifit_fdfridge_wset2 (gsl_multifit_fdfridge * @var{s}, gsl_multifit_function_fdf * @var{fdf}, const gsl_vector * @var{x}, const gsl_vector * @var{lambda}, const gsl_vector * @var{wts})
+This function initializes, or reinitializes, an existing ridge solver
+@var{s} to use the function and derivative @var{fdf} and the initial
+guess @var{x}. Here, the regularization matrix is set to
+@math{L = diag(\lambda_1,\lambda_2,...,\lambda_p)}, where
+the @math{\lambda_i} are given in @var{lambda}.
+
+Optionally, a weight vector @var{wts} can be given to perform
+a weighted nonlinear regression. Here, the weighting matrix is
+@math{W = diag(w_1,w_2,...,w_n)}. The @var{wts} vector is referenced
+throughout the iteration so it should not be freed by the caller until
+the iteration terminates.
+@end deftypefun
+
+@deftypefun int gsl_multifit_fdfridge_set3 (gsl_multifit_fdfridge * @var{s}, gsl_multifit_function_fdf * @var{fdf}, const gsl_vector * @var{x}, const gsl_matrix * @var{L})
+@deftypefunx int gsl_multifit_fdfridge_wset3 (gsl_multifit_fdfridge * @var{s}, gsl_multifit_function_fdf * @var{fdf}, const gsl_vector * @var{x}, const gsl_matrix * @var{L}, const gsl_vector * @var{wts})
+This function initializes, or reinitializes, an existing ridge solver
+@var{s} to use the function and derivative @var{fdf} and the initial
+guess @var{x}. Here, the regularization matrix is set to @var{L},
+which must have @math{p} columns but may have any number of rows.
+
+Optionally, a weight vector @var{wts} can be given to perform
+a weighted nonlinear regression. Here, the weighting matrix is
+@math{W = diag(w_1,w_2,...,w_n)}. The @var{wts} vector is referenced
+throughout the iteration so it should not be freed by the caller until
+the iteration terminates.
+@end deftypefun
+
+@deftypefun void gsl_multifit_fsolver_free (gsl_multifit_fsolver * @var{s})
+@deftypefunx void gsl_multifit_fdfsolver_free (gsl_multifit_fdfsolver * @var{s})
+@deftypefunx void gsl_multifit_fdfridge_free (gsl_multifit_fdfridge * @var{s})
+These functions free all the memory associated with the solver @var{s}.
+@end deftypefun
+
+@deftypefun {const char *} gsl_multifit_fsolver_name (const gsl_multifit_fsolver * @var{s})
+@deftypefunx {const char *} gsl_multifit_fdfsolver_name (const gsl_multifit_fdfsolver * @var{s})
+@deftypefunx {const char *} gsl_multifit_fdfridge_name (const gsl_multifit_fdfridge * @var{s})
+These functions return a pointer to the name of the solver.  For example,
+
+@example
+printf ("s is a '%s' solver\n", 
+        gsl_multifit_fdfsolver_name (s));
+@end example
+
+@noindent
+would print something like @code{s is a 'lmder' solver}.
+@end deftypefun
+
+@node Providing the Function to be Minimized
+@section Providing the Function to be Minimized
+
+You must provide @math{n} functions of @math{p} variables for the
+minimization algorithms to operate on.  In order to allow for
+arbitrary parameters the functions are defined by the following data
+types:
+
+@deftp {Data Type} gsl_multifit_function 
+This data type defines a general system of functions with arbitrary parameters.  
+
+@table @code
+@item int (* f) (const gsl_vector * @var{x}, void * @var{params}, gsl_vector * @var{f})
+this function should store the vector result
+@c{$f(x,\hbox{\it params})$}
+@math{f(x,params)} in @var{f} for argument @var{x} and arbitrary parameters @var{params},
+returning an appropriate error code if the function cannot be computed.
+
+@item size_t n
+the number of functions, i.e. the number of components of the
+vector @var{f}.
+
+@item size_t p
+the number of independent variables, i.e. the number of components of
+the vector @var{x}.
+
+@item void * params
+a pointer to the arbitrary parameters of the function.
+@end table
+@end deftp
+
+@deftp {Data Type} gsl_multifit_function_fdf
+This data type defines a general system of functions with arbitrary parameters and
+the corresponding Jacobian matrix of derivatives,
+
+@table @code
+@item int (* f) (const gsl_vector * @var{x}, void * @var{params}, gsl_vector * @var{f})
+this function should store the vector result
+@c{$f(x,\hbox{\it params})$}
+@math{f(x,params)} in @var{f} for argument @var{x} and arbitrary parameters @var{params},
+returning an appropriate error code if the function cannot be computed.
+
+@item int (* df) (const gsl_vector * @var{x}, void * @var{params}, gsl_matrix * @var{J})
+this function should store the @var{n}-by-@var{p} matrix result
+@c{$J_{ij} = \partial f_i(x,\hbox{\it params}) / \partial x_j$}
+@math{J_ij = d f_i(x,params) / d x_j} in @var{J} for argument @var{x} 
+and arbitrary parameters @var{params}, returning an appropriate error code if the
+function cannot be computed. If an analytic Jacobian is unavailable, or too expensive
+to compute, this function pointer may be set to NULL, in which
+case the Jacobian will be internally computed using finite difference approximations
+of the function @var{f}.
+
+@item size_t n
+the number of functions, i.e. the number of components of the
+vector @var{f}.
+
+@item size_t p
+the number of independent variables, i.e. the number of components of
+the vector @var{x}.
+
+@item void * params
+a pointer to the arbitrary parameters of the function.
+
+@item size_t nevalf
+This does not need to be set by the user. It counts the number of
+function evaluations and is initialized by the @code{_set} function.
+
+@item size_t nevaldf
+This does not need to be set by the user. It counts the number of
+Jacobian evaluations and is initialized by the @code{_set} function.
+@end table
+@end deftp
+
+Note that when fitting a non-linear model against experimental data,
+the data is passed to the functions above using the
+@var{params} argument and the trial best-fit parameters through the
+@var{x} argument.
+
+@node Finite Difference Jacobian
+@section Finite Difference Jacobian
+
+For the algorithms which require a Jacobian matrix of derivatives of
+the fit functions, there are times when an analytic Jacobian may be
+unavailable or too expensive to compute. Therefore GSL supports
+approximating the Jacobian numerically using finite differences of the fit
+functions. This is typically done by setting the relevant function pointers
+of the @code{gsl_multifit_function_fdf} data type to NULL, however the
+following functions allow the user to access the approximate Jacobian
+directly if needed.
+
+@deftypefun int gsl_multifit_fdfsolver_dif_df (const gsl_vector * @var{x}, const gsl_vector * @var{wts}, gsl_multifit_function_fdf * @var{fdf}, const gsl_vector * @var{f}, gsl_matrix * @var{J})
+This function takes as input the current position @var{x}, weight
+vector @var{wts} and function values computed at the current position
+@var{f}, along with @var{fdf} which specifies the fit function and
+parameters and approximates the
+@var{n}-by-@var{p} Jacobian @var{J} using forward finite differences:
+@c{$J_{ij} = \sqrt{w_i} \partial f_i(x) / \partial x_j \approx \sqrt{w_i} (f_i(x + h_j e_j) - f_i(x)) / h_j$}
+@math{J_ij = sqrt(w_i) d f_i(x) / d x_j = sqrt(w_i) (f_i(x + h_j e_j) - f_i(x)) / h_j}.
+where @math{h_j = \epsilon |x_j|}, and @math{\epsilon} is the
+square root of the machine precision @code{GSL_DBL_EPSILON}.
+@end deftypefun
+
+@deftypefun int gsl_multifit_fdfsolver_dif_fdf (const gsl_vector * @var{x}, gsl_multifit_function_fdf * @var{fdf}, gsl_vector * @var{f}, gsl_matrix * @var{J})
+This function is deprecated and will be removed in a future release.
+@end deftypefun
+
+@node Iteration of the Minimization Algorithm
+@section Iteration
+
+The following functions drive the iteration of each algorithm.  Each
+function performs one iteration to update the state of any solver of the
+corresponding type.  The same functions work for all solvers so that
+different methods can be substituted at runtime without modifications to
+the code.
+
+@deftypefun int gsl_multifit_fsolver_iterate (gsl_multifit_fsolver * @var{s})
+@deftypefunx int gsl_multifit_fdfsolver_iterate (gsl_multifit_fdfsolver * @var{s})
+@deftypefunx int gsl_multifit_fdfridge_iterate (gsl_multifit_fdfridge * @var{s})
+These functions perform a single iteration of the solver @var{s}.  If
+the iteration encounters an unexpected problem then an error code will
+be returned.  The solver maintains a current estimate of the best-fit
+parameters at all times. 
+@end deftypefun
+
+The solver struct @var{s} contains the following entries, which can
+be used to track the progress of the solution:
+
+@table @code
+@item gsl_vector * x
+The current position.
+
+@item gsl_vector * f
+The function residual vector at the current position @math{f(x)}.
+
+@item gsl_vector * dx
+The difference between the current position and the previous position,
+i.e. the last step @math{\delta}, taken as a vector.
+
+@end table
+
+The best-fit information also can be accessed with the following
+auxiliary functions,
+
+@deftypefun {gsl_vector *} gsl_multifit_fsolver_position (const gsl_multifit_fsolver * @var{s})
+@deftypefunx {gsl_vector *} gsl_multifit_fdfsolver_position (const gsl_multifit_fdfsolver * @var{s})
+@deftypefunx {gsl_vector *} gsl_multifit_fdfridge_position (const gsl_multifit_fdfridge * @var{s})
+These functions return the current position @math{x} (i.e. best-fit
+parameters) of the solver @var{s}.
+@end deftypefun
+
+@deftypefun {gsl_vector *} gsl_multifit_fdfsolver_residual (const gsl_multifit_fdfsolver * @var{s})
+@deftypefunx {gsl_vector *} gsl_multifit_fdfridge_residual (const gsl_multifit_fdfridge * @var{s})
+These functions return the current residual vector @math{f} of the
+solver @var{s}.  For weighted cases, the residual vector includes the
+weighting factor @math{\sqrt{W}}. For ridge regression, the residual
+vector is the augmented vector @math{\tilde{f}}.
+@end deftypefun
+
+@deftypefun size_t gsl_multifit_fdfsolver_niter (const gsl_multifit_fdfsolver * @var{s})
+@deftypefunx size_t gsl_multifit_fdfridge_niter (const gsl_multifit_fdfridge * @var{s})
+These functions return the number of iterations performed so far.
+The iteration counter is updated on each call to the
+@code{_iterate} functions above, and reset to 0 in the
+@code{_set} functions.
+@end deftypefun
+
+@node Search Stopping Parameters for Minimization Algorithms
+@section Search Stopping Parameters
+@cindex nonlinear fitting, stopping parameters
+
+A minimization procedure should stop when one of the following conditions is
+true:
+
+@itemize @bullet
+@item
+A minimum has been found to within the user-specified precision.
+
+@item
+A user-specified maximum number of iterations has been reached.
+
+@item
+An error has occurred.
+@end itemize
+
+@noindent
+The handling of these conditions is under user control.  The functions
+below allow the user to test the current estimate of the best-fit
+parameters in several standard ways.
+
+@deftypefun int gsl_multifit_fdfsolver_test (const gsl_multifit_fdfsolver * @var{s}, const double @var{xtol}, const double @var{gtol}, const double @var{ftol}, int * @var{info})
+This function tests for convergence of the minimization method
+using the following criteria:
+
+@itemize @bullet
+@item
+Testing for a small step size relative to the current parameter vector
+@tex
+\beforedisplay
+$$
+|\delta_i| \le xtol (|x_i| + xtol)
+$$
+\afterdisplay
+@end tex
+@ifinfo
+@example
+|\delta_i| <= xtol (|x_i| + xtol)
+@end example
+@end ifinfo
+for each @math{0 <= i < p}. Each element of the step vector @math{\delta}
+is tested individually in case the different parameters have widely
+different scales. Adding @var{xtol} to @math{|x_i|} helps the test avoid
+breaking down in situations where the true solution value @math{x_i = 0}.
+If this test succeeds, @var{info} is set to 1 and the function
+returns @code{GSL_SUCCESS}.
+
+A general guideline for selecting the step tolerance is to choose
+@math{xtol = 10^{-d}} where @math{d} is the number of accurate
+decimal digits desired in the solution @math{x}. See Dennis and
+Schnabel for more information.
+
+@item
+Testing for a small gradient (@math{g = \nabla \Phi(x) = J^T f})
+indicating a local function minimum:
+@tex
+\beforedisplay
+$$
+max_i |g_i \times max(x_i, 1)| \le gtol \times max(\Phi(x), 1)
+$$
+\afterdisplay
+@end tex
+@ifinfo
+@example
+||g||_inf <= gtol
+@end example
+@end ifinfo
+This expression tests whether the ratio
+@math{(\nabla \Phi)_i x_i / \Phi} is small. Testing this scaled gradient
+is a better than @math{\nabla \Phi} alone since it is a dimensionless
+quantity and so independent of the scale of the problem. The
+@code{max} arguments help ensure the test doesn't break down in
+regions where @math{x_i} or @math{\Phi(x)} are close to 0.
+If this test succeeds, @var{info} is set to 2 and the function
+returns @code{GSL_SUCCESS}.
+
+A general guideline for choosing the gradient tolerance is to set
+@code{gtol = GSL_DBL_EPSILON^(1/3)}. See Dennis and Schnabel for
+more information.
+
+@end itemize
+
+If none of the tests succeed, @var{info} is set to 0 and the
+function returns @code{GSL_CONTINUE}, indicating further iterations
+are required.
+
+@end deftypefun
+
+@deftypefun int gsl_multifit_test_delta (const gsl_vector * @var{dx}, const gsl_vector * @var{x}, double @var{epsabs}, double @var{epsrel})
+
+This function tests for the convergence of the sequence by comparing the
+last step @var{dx} with the absolute error @var{epsabs} and relative
+error @var{epsrel} to the current position @var{x}.  The test returns
+@code{GSL_SUCCESS} if the following condition is achieved,
+@tex
+\beforedisplay
+$$
+|dx_i| < \hbox{\it epsabs} + \hbox{\it epsrel\/}\, |x_i|
+$$
+\afterdisplay
+@end tex
+@ifinfo
+
+@example
+|dx_i| < epsabs + epsrel |x_i|
+@end example
+
+@end ifinfo
+@noindent
+for each component of @var{x} and returns @code{GSL_CONTINUE} otherwise.
+@end deftypefun
+
+@cindex residual, in nonlinear systems of equations
+@deftypefun int gsl_multifit_test_gradient (const gsl_vector * @var{g}, double @var{epsabs})
+This function tests the residual gradient @var{g} against the absolute
+error bound @var{epsabs}.  Mathematically, the gradient should be
+exactly zero at the minimum. The test returns @code{GSL_SUCCESS} if the
+following condition is achieved,
+@tex
+\beforedisplay
+$$
+\sum_i |g_i| < \hbox{\it epsabs}
+$$
+\afterdisplay
+@end tex
+@ifinfo
+
+@example
+\sum_i |g_i| < epsabs
+@end example
+
+@end ifinfo
+@noindent
+and returns @code{GSL_CONTINUE} otherwise.  This criterion is suitable
+for situations where the precise location of the minimum, @math{x},
+is unimportant provided a value can be found where the gradient is small
+enough.
+@end deftypefun
+
+
+@deftypefun int gsl_multifit_gradient (const gsl_matrix * @var{J}, const gsl_vector * @var{f}, gsl_vector * @var{g})
+This function computes the gradient @var{g} of @math{\Phi(x) = (1/2)
+||f(x)||^2} from the Jacobian matrix @math{J} and the function values
+@var{f}, using the formula @math{g = J^T f}.
+@end deftypefun
+
+@node High Level Driver
+@section High Level Driver
+
+These routines provide a high level wrapper that combine the iteration
+and convergence testing for easy use.
+
+@deftypefun int gsl_multifit_fsolver_driver (gsl_multifit_fsolver * @var{s}, const size_t @var{maxiter}, const double @var{epsabs}, const double @var{epsrel})
+This function iterates the solver @var{s} for a maximum of @var{maxiter}
+iterations. After each iteration, the system is tested for convergence
+using @code{gsl_multifit_test_delta} with the error tolerances @var{epsabs}
+and @var{epsrel}.
+@end deftypefun
+
+@deftypefun int gsl_multifit_fdfsolver_driver (gsl_multifit_fdfsolver * @var{s}, const size_t @var{maxiter}, const double @var{xtol}, const double @var{gtol}, const double @var{ftol}, int * @var{info})
+@deftypefunx int gsl_multifit_fdfridge_driver (gsl_multifit_fdfridge * @var{s}, const size_t @var{maxiter}, const double @var{xtol}, const double @var{gtol}, const double @var{ftol}, int * @var{info})
+These functions iterate the solver @var{s} for a maximum of @var{maxiter}
+iterations. After each iteration, the system is tested for convergence
+with the error tolerances @var{xtol}, @var{gtol} and @var{ftol}.
+Upon successful convergence,
+the function returns @code{GSL_SUCCESS} and sets @var{info} to
+the reason for convergence (see @code{gsl_multifit_fdfsolver_test}).
+Otherwise, the function returns @code{GSL_EMAXITER} indicating
+the system did not converge after @var{maxiter} iterations.
+@end deftypefun
+
+@node Minimization Algorithms using Derivatives
+@section Minimization Algorithms using Derivatives
+
+The minimization algorithms described in this section make use of both
+the function and its derivative.  They require an initial guess for the
+location of the minimum. There is no absolute guarantee of
+convergence---the function must be suitable for this technique and the
+initial guess must be sufficiently close to the minimum for it to work.
+
+@comment ============================================================
+@cindex Levenberg-Marquardt algorithms
+
+@deffn {Derivative Solver} gsl_multifit_fdfsolver_lmsder
+@cindex LMDER algorithm
+@cindex MINPACK, minimization algorithms
+
+This is a robust and efficient version of the Levenberg-Marquardt
+algorithm as implemented in the scaled @sc{lmder} routine in
+@sc{minpack}.  Minpack was written by Jorge J. Mor@'e, Burton S. Garbow
+and Kenneth E. Hillstrom.
+
+The algorithm uses a generalized trust region to keep each step under
+control.  In order to be accepted a proposed new position @math{x'} must
+satisfy the condition @math{|D (x' - x)| < \Delta}, where @math{D} is a
+diagonal scaling matrix and @math{\Delta} is the size of the trust
+region.  The components of @math{D} are computed internally, using the
+column norms of the Jacobian to estimate the sensitivity of the residual
+to each component of @math{x}.  This improves the behavior of the
+algorithm for badly scaled functions.
+
+On each iteration the algorithm attempts to minimize the linear system
+@math{|f + J \delta|} subject to the constraint @math{|D \delta| < \Delta}.
+The solution to this constrained linear system is found by solving
+the linear least squares system
+@tex
+\beforedisplay
+$$
+\left[
+\matrix{
+J \cr
+\sqrt{\mu} D
+}
+\right]
+\delta =
+-
+\left[
+\matrix{
+f \cr
+0
+}
+\right]
+$$
+\afterdisplay
+@end tex
+@ifinfo
+
+@example
+[J; sqrt(mu) D] \delta = - [f; 0]
+@end example
+
+@end ifinfo
+where @math{\mu} is the Levenberg-Marquardt parameter. The above
+system is solved using a QR decomposition of @math{J}.
+
+The proposed step @math{\delta} is now tested by evaluating the
+function at the resulting point, @math{x'}.  If the step reduces the norm of the
+function sufficiently, and follows the predicted behavior of the
+function within the trust region, then it is accepted and the size of the
+trust region is increased.  If the proposed step fails to improve the
+solution, or differs significantly from the expected behavior within
+the trust region, then the size of the trust region is decreased and
+another trial step is computed.
+
+The algorithm also monitors the progress of the solution and returns an
+error if the changes in the solution are smaller than the machine
+precision.  The possible error codes are,
+
+@table @code
+@item GSL_ETOLF
+the decrease in the function falls below machine precision
+
+@item GSL_ETOLX
+the change in the position vector falls below machine precision
+
+@item GSL_ETOLG
+the norm of the gradient, relative to the norm of the function, falls
+below machine precision
+
+@item GSL_ENOPROG
+the routine has made 10 or more attempts to find a suitable trial step
+without success (but subsequent calls can be made to continue the
+search).@footnote{The return code @code{GSL_CONTINUE} was used for
+this case in versions prior to 1.14.}
+@end table
+
+@noindent
+These error codes indicate that further iterations will be unlikely to
+change the solution from its current value.  
+@end deffn
+
+@deffn {Derivative Solver} gsl_multifit_fdfsolver_lmder
+
+This is an unscaled version of the @sc{lmder} algorithm.  The elements of the
+diagonal scaling matrix @math{D} are set to 1.  This algorithm may be
+useful in circumstances where the scaled version of @sc{lmder} converges too
+slowly, or the function is already scaled appropriately.
+@end deffn
+
+@deffn {Derivative Solver} gsl_multifit_fdfsolver_lmniel
+
+This is a Levenberg-Marquardt solver based on a smoother updating
+procedure for the damping parameter @math{\mu} proposed by
+Nielsen, 1999. It does not use a trust region approach and only
+performs rudimentary scaling and is therefore not as robust as
+@code{lmsder}. However, on each iteration it solves the normal
+equation system to compute the next step:
+@tex
+\beforedisplay
+$$
+\left( J^T J + \mu I \right) \delta = - J^T f
+$$
+\afterdisplay
+@end tex
+@ifinfo
+
+@example
+(J^T J + \mu I) \delta = -J^T f
+@end example
+
+@end ifinfo
+which makes it a much more practical method for problems with a
+large number of residuals (@math{n >> p}), since only the
+@math{p}-by-@math{p} matrix @math{J^T J} is decomposed rather than
+the full @math{n}-by-@math{p} Jacobian. This makes a significant
+difference in efficiency when solving systems with large amounts
+of data. While not as robust as @code{lmsder}, this algorithm has
+proven effective on a wide class of problems.
+@end deffn
+
+@node Minimization Algorithms without Derivatives
+@section Minimization Algorithms without Derivatives
+
+There are no algorithms implemented in this section at the moment.
+
+@node Computing the covariance matrix of best fit parameters
+@section Computing the covariance matrix of best fit parameters
+@cindex best-fit parameters, covariance
+@cindex least squares, covariance of best-fit parameters
+@cindex covariance matrix, nonlinear fits
+
+@deftypefun int gsl_multifit_fdfsolver_jac (gsl_multifit_fdfsolver * @var{s}, gsl_matrix * @var{J})
+This function stores the @math{n}-by-@math{p} Jacobian matrix for the
+current iteration of the solver @var{s} into the output @var{J}.
+@end deftypefun
+
+@deftypefun int gsl_multifit_covar (const gsl_matrix * @var{J}, const double @var{epsrel}, gsl_matrix * @var{covar})
+This function computes the covariance matrix of best-fit parameters
+using the Jacobian matrix @var{J} and stores it in @var{covar}.
+The parameter @var{epsrel} is used to remove linear-dependent columns
+when @var{J} is rank deficient.
+
+The covariance matrix is given by,
+@tex
+\beforedisplay
+$$
+C = (J^T J)^{-1}
+$$
+\afterdisplay
+@end tex
+@ifinfo
+
+@example
+covar = (J^T J)^@{-1@}
+@end example
+
+@end ifinfo
+or in the weighted case,
+@tex
+\beforedisplay
+$$
+C = (J^T W J)^{-1}
+$$
+\afterdisplay
+@end tex
+@ifinfo
+
+@example
+covar = (J^T W J)^@{-1@}
+@end example
+
+@end ifinfo
+@noindent
+and is computed by QR decomposition of J with column-pivoting.  Any
+columns of @math{R} which satisfy 
+@tex
+\beforedisplay
+$$
+|R_{kk}| \leq epsrel |R_{11}|
+$$
+\afterdisplay
+@end tex
+@ifinfo
+
+@example
+|R_@{kk@}| <= epsrel |R_@{11@}|
+@end example
+
+@end ifinfo
+@noindent
+are considered linearly-dependent and are excluded from the covariance
+matrix (the corresponding rows and columns of the covariance matrix are
+set to zero).
+
+If the minimisation uses the weighted least-squares function
+@math{f_i = (Y(x, t_i) - y_i) / \sigma_i} then the covariance
+matrix above gives the statistical error on the best-fit parameters
+resulting from the Gaussian errors @math{\sigma_i} on 
+the underlying data @math{y_i}.  This can be verified from the relation 
+@math{\delta f = J \delta c} and the fact that the fluctuations in @math{f}
+from the data @math{y_i} are normalised by @math{\sigma_i} and 
+so satisfy @c{$\langle \delta f \delta f^T \rangle = I$}
+@math{<\delta f \delta f^T> = I}.
+
+For an unweighted least-squares function @math{f_i = (Y(x, t_i) -
+y_i)} the covariance matrix above should be multiplied by the variance
+of the residuals about the best-fit @math{\sigma^2 = \sum (y_i - Y(x,t_i))^2 / (n-p)}
+to give the variance-covariance
+matrix @math{\sigma^2 C}.  This estimates the statistical error on the
+best-fit parameters from the scatter of the underlying data.
+
+For more information about covariance matrices see @ref{Fitting Overview}.
+@end deftypefun
+
+@comment ============================================================
+
+@node Troubleshooting Nonlinear Least Squares
+@section Troubleshooting
+
+When developing a code to solve a nonlinear least squares problem,
+here are a few considerations to keep in mind.
+
+@enumerate
+
+@item
+The most common difficulty is the accurate implementation of the Jacobian
+matrix. If the analytic Jacobian is not properly provided to the
+solver, this can hinder and many times prevent convergence of the method.
+When developing a new nonlinear least squares code, it often helps
+to compare the program output with the internally computed finite
+difference Jacobian and the user supplied analytic Jacobian. If there
+is a large difference in coefficients, it is likely the analytic
+Jacobian is incorrectly implemented.
+
+@item
+If your code is having difficulty converging, the next thing to
+check is the starting point provided to the solver. The methods
+of this chapter are local methods, meaning if you provide a starting
+point far away from the true minimum, the method may converge to
+a local minimum or not converge at all. Sometimes it is possible
+to solve a linearized approximation to the nonlinear problem,
+and use the linear solution as the starting point to the nonlinear
+problem.
+
+@item
+If the various parameters of the coefficient vector @math{x}
+vary widely in magnitude, then the problem is said to be badly scaled.
+The methods of this chapter do attempt to automatically rescale
+the elements of @math{x} to have roughly the same order of magnitude,
+but in extreme cases this could still cause problems for convergence.
+In these cases it is recommended for the user to scale their
+parameter vector @math{x} so that each parameter spans roughly the
+same range, say @math{[-1,1]}. The solution vector can be backscaled
+to recover the original units of the problem.
+
+@end enumerate
+
+@node Example programs for Nonlinear Least-Squares Fitting
+@section Examples
+
+The following example program fits a weighted exponential model with
+background to experimental data, @math{Y = A \exp(-\lambda t) + b}. The
+first part of the program sets up the functions @code{expb_f} and
+@code{expb_df} to calculate the model and its Jacobian.  The appropriate
+fitting function is given by,
+@tex
+\beforedisplay
+$$
+f_i = (A \exp(-\lambda t_i) + b) - y_i
+$$
+\afterdisplay
+@end tex
+@ifinfo
+
+@example
+f_i = (A \exp(-\lambda t_i) + b) - y_i
+@end example
+
+@end ifinfo
+@noindent
+where we have chosen @math{t_i = i}.  The Jacobian matrix @math{J} is
+the derivative of these functions with respect to the three parameters
+(@math{A}, @math{\lambda}, @math{b}).  It is given by,
+@tex
+\beforedisplay
+$$
+J_{ij} = {\partial f_i \over \partial x_j}
+$$
+\afterdisplay
+@end tex
+@ifinfo
+
+@example
+J_@{ij@} = d f_i / d x_j
+@end example
+
+@end ifinfo
+@noindent
+where @math{x_0 = A}, @math{x_1 = \lambda} and @math{x_2 = b}. The
+weights are given by @math{w_i = 1/\sigma_i^2}.
+
+@example
+@verbatiminclude examples/expfit.c
+@end example
+
+@noindent
+The main part of the program sets up a Levenberg-Marquardt solver and
+some simulated random data. The data uses the known parameters
+(5.0,0.1,1.0) combined with Gaussian noise (standard deviation = 0.1)
+over a range of 40 timesteps. The initial guess for the parameters is
+chosen as (0.0, 1.0, 0.0).
+
+@example
+@verbatiminclude examples/nlfit.c
+@end example
+
+@noindent
+The iteration terminates when the relative change in x is smaller than
+@math{10^{-8}}, or when the magnitude of the gradient falls below
+@math{10^{-8}}.
+Here are the results of running the program:
+
+@smallexample
+summary from method 'lmsder'
+number of iterations: 8
+function evaluations: 11
+Jacobian evaluations: 9
+reason for stopping: small step size
+initial |f(x)| = 31.1919
+final   |f(x)| = 5.45418
+chisq/dof = 0.804002
+A      = 5.17379 +/- 0.27938
+lambda = 0.11104 +/- 0.00817
+b      = 1.05283 +/- 0.05365
+status = success
+@end smallexample
+
+@noindent
+The approximate values of the parameters are found correctly, and the
+chi-squared value indicates a good fit (the chi-squared per degree of
+freedom is approximately 1).  In this case the errors on the parameters
+can be estimated from the square roots of the diagonal elements of the
+covariance matrix.  
+
+If the chi-squared value shows a poor fit (i.e. @c{$\chi^2/(n-p) \gg 1$}
+@math{chi^2/dof >> 1}) then the error estimates obtained from the
+covariance matrix will be too small.  In the example program the error estimates
+are multiplied by @c{$\sqrt{\chi^2/(n-p)}$}
+@math{\sqrt@{\chi^2/dof@}} in this case, a common way of increasing the
+errors for a poor fit.  Note that a poor fit will result from the use
+an inappropriate model, and the scaled error estimates may then
+be outside the range of validity for Gaussian errors.
+
+@iftex
+@sp 1
+@center @image{fit-exp,3.4in}
+@end iftex
+
+@node References and Further Reading for Nonlinear Least-Squares Fitting
+@section References and Further Reading
+
+The @sc{minpack} algorithm is described in the following article,
+
+@itemize @w{}
+@item
+J.J. Mor@'e, @cite{The Levenberg-Marquardt Algorithm: Implementation and
+Theory}, Lecture Notes in Mathematics, v630 (1978), ed G. Watson.
+@end itemize
+
+@noindent
+The @code{lmniel} algorithm closely follows the following publications,
+
+@itemize @w{}
+@item
+H. B. Nielsen, ``Damping Parameter in Marquardt's Method'',
+IMM Department of Mathematical Modeling, DTU, Tech. Report IMM-REP-1999-05
+(1999).
+
+@item
+K. Madsen and H. B. Nielsen, ``Introduction to Optimization and Data
+Fitting'', IMM Department of Mathematical Modeling, DTU, 2010.
+@end itemize
+
+@noindent
+The following publications are also relevant to the algorithms described
+in this section,
+
+@itemize @w{}
+@item
+J. E. Dennis and R. B. Schnabel, Numerical Methods for Unconstrained
+Optimization and Nonlinear Equations, SIAM, 1996.
+
+@item 
+J.J. Mor@'e, B.S. Garbow, K.E. Hillstrom, ``Testing Unconstrained
+Optimization Software'', ACM Transactions on Mathematical Software, Vol
+7, No 1 (1981), p 17--41.
+
+@item 
+H. B. Nielsen, ``UCTP Test Problems for Unconstrained Optimization'',
+IMM Department of Mathematical Modeling, DTU, Tech. Report IMM-REP-2000-17
+(2000).
+@end itemize
+
diff --git a/gsl.pc.cmake b/gsl.pc.cmake
new file mode 100644
index 0000000..6f313c1
--- /dev/null
+++ b/gsl.pc.cmake
@@ -0,0 +1,11 @@
+prefix=@CMAKE_INSTALL_PREFIX@
+exec_prefix=@CMAKE_INSTALL_PREFIX@
+libdir=${prefix}/lib
+includedir=${prefix}/include
+GSL_CBLAS_LIB=-lgslcblas
+
+Name: GSL
+Description: GNU Scientific Library
+Version: @PACKAGE_VERSION@
+Libs: -L${libdir} -lgsl ${GSL_CBLAS_LIB} -lm -lm
+Cflags: -I${includedir}
diff --git a/ieee-utils/fp-win.c b/ieee-utils/fp-win.c
new file mode 100644
index 0000000..e024eae
--- /dev/null
+++ b/ieee-utils/fp-win.c
@@ -0,0 +1,70 @@
+/* fp-win.c
+ * 
+ * Author: Brian Gladman
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at
+ * your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+#include <float.h>
+
+#include <config.h>
+#include <gsl/gsl_ieee_utils.h>
+#include <gsl/gsl_errno.h>
+
+const char *fp_env_string = "round-to-nearest,double-precision,mask-all";
+
+int
+gsl_ieee_set_mode (int precision, int rounding, int exception_mask)
+{
+	unsigned int old, mode = _DN_SAVE, mask = _MCW_DN | _MCW_RC | _MCW_EM;
+
+	switch(precision)
+    {
+    case GSL_IEEE_SINGLE_PRECISION:		mode |= _PC_24; break;
+    case GSL_IEEE_EXTENDED_PRECISION:	mode |= _PC_64; break;
+    case GSL_IEEE_DOUBLE_PRECISION:
+    default:							mode |= _PC_53;
+	}
+#ifndef _M_AMD64
+	mask |= _MCW_PC;
+#endif
+
+	switch(rounding)
+    {
+    case GSL_IEEE_ROUND_DOWN:			mode |= _RC_DOWN; break;
+    case GSL_IEEE_ROUND_UP:				mode |= _RC_UP;   break;
+    case GSL_IEEE_ROUND_TO_ZERO:		mode |= _RC_CHOP; break;
+    case GSL_IEEE_ROUND_TO_NEAREST:
+    default:							mode |= _RC_NEAR;
+    }
+
+	if(exception_mask & GSL_IEEE_MASK_INVALID)
+		mode |= _EM_INVALID;
+	if(exception_mask & GSL_IEEE_MASK_DENORMALIZED)
+		mode |= _EM_DENORMAL;
+	if(exception_mask & GSL_IEEE_MASK_DIVISION_BY_ZERO)
+		mode |= _EM_ZERODIVIDE;
+	if(exception_mask & GSL_IEEE_MASK_OVERFLOW)
+		mode |= _EM_OVERFLOW;
+	if(exception_mask & GSL_IEEE_MASK_UNDERFLOW)
+		mode |= _EM_UNDERFLOW;
+	if(exception_mask & GSL_IEEE_TRAP_INEXACT)
+		mode &= ~_EM_INEXACT;
+	else
+		mode |= _EM_INEXACT;
+
+	_controlfp_s( &old, mode, mask);
+	return GSL_SUCCESS;
+}
-- 
2.10.0

